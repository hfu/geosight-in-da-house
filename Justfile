# GeoSight in-da-house Justfile
# For Raspberry Pi OS trixie 64bit on Raspberry Pi 4B
# Based on knowledge from UNopenGIS/7 issue #821

# Default variables - optimized for Raspberry Pi 4B (4GB RAM)
GEOSIGHT_REPO := "https://github.com/unicef-drp/GeoSight-OS.git"
GEOSIGHT_DIR := "GeoSight-OS"
HTTP_PORT := "2000"
HTTPS_PORT := "2443"

# Raspberry Pi optimized settings
# These can be overridden with: just --set VARIABLE value
COMPOSE_HTTP_TIMEOUT := "300"
DOCKER_CLIENT_TIMEOUT := "300"

# Docker resource limits for Raspberry Pi (optional, uncomment if needed)
# DOCKER_MEMORY_LIMIT := "2g"
# DOCKER_CPU_LIMIT := "2"

# Default recipe: show available commands
default:
    @just --list

# Check prerequisites
_check-docker:
    #!/usr/bin/env bash
    set -euo pipefail
    if ! command -v docker &> /dev/null; then
        echo "âŒ Docker is not installed. Run 'just install' first."
        exit 1
    fi
    if ! docker info &> /dev/null; then
        echo "âŒ Docker daemon is not running or you don't have permission."
        echo "   Try: sudo systemctl start docker"
        echo "   Or: log out and log back in if you just added yourself to the docker group"
        exit 1
    fi

# Check if GeoSight directory exists
_check-geosight:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ ! -d "{{GEOSIGHT_DIR}}" ]; then
        echo "âŒ GeoSight-OS directory not found. Run 'just install' first."
        exit 1
    fi

# Install all required packages and clone GeoSight-OS
install:
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Installing GeoSight for Raspberry Pi"
    echo "======================================"
    echo ""
    
    # Update package lists
    echo "ðŸ“¦ Updating package lists..."
    sudo apt-get update
    
    # Install required packages
    echo "ðŸ“¦ Installing required packages..."
    sudo apt-get install -y \
        git \
        docker.io \
        docker-compose-plugin \
        curl \
        make \
        openssl
    
    # Enable and start Docker
    echo "ðŸ³ Enabling Docker service..."
    sudo systemctl enable docker
    sudo systemctl start docker
    
    # Add current user to docker group if not already
    if ! groups | grep -q docker; then
        echo "ðŸ‘¤ Adding user to docker group..."
        sudo usermod -aG docker $USER
        echo ""
        echo "âš ï¸  IMPORTANT: Docker group membership added."
        echo "   Please log out and log back in, then run:"
        echo "   just install"
        echo ""
        exit 2
    fi
    
    # Verify docker works
    if ! docker info &> /dev/null; then
        echo "âš ï¸  Docker is running but you may need to log out and log back in"
        echo "   for group permissions to take effect."
        exit 1
    fi
    
    # Clone GeoSight-OS if not exists
    if [ ! -d "{{GEOSIGHT_DIR}}" ]; then
        echo "ðŸ“¥ Cloning GeoSight-OS repository..."
        git clone --depth 1 {{GEOSIGHT_REPO}}
    else
        echo "âœ… GeoSight-OS directory already exists"
        echo "   Pulling latest changes..."
        cd {{GEOSIGHT_DIR}} && git pull || true
        cd ..
    fi
    
    # Run setup
    echo "ðŸ”§ Running GeoSight setup..."
    cd {{GEOSIGHT_DIR}}
    
    # Generate random secret key and passwords for security
    SECRET_KEY=$(openssl rand -base64 32 | tr -d '/+=' | head -c 50)
    DB_PASSWORD=$(openssl rand -base64 16 | tr -d '/+=' | head -c 16)
    REDIS_PASSWORD=$(openssl rand -base64 16 | tr -d '/+=' | head -c 16)
    
    # Get port from Justfile variable (passed through)
    HTTP_PORT_VAL="{{HTTP_PORT}}"
    HTTPS_PORT_VAL="{{HTTPS_PORT}}"
    
    # Create .env file with Raspberry Pi optimized settings
    if [ ! -f deployment/.env ]; then
        echo "ðŸ”§ Creating deployment/.env with Raspberry Pi optimized settings..."
        {
            echo "# GeoSight configuration optimized for Raspberry Pi 4B"
            echo "# Generated by geosight-in-da-house"
            echo ""
            echo "# Security - These credentials were randomly generated"
            echo "# IMPORTANT: Change ADMIN_PASSWORD after first login!"
            echo "SECRET_KEY=${SECRET_KEY}"
            echo ""
            echo "COMPOSE_PROJECT_NAME=geosight"
            echo "NGINX_TAG=0.0.1"
            echo "DJANGO_TAG=3.1.0"
            echo ""
            echo "# Django settings - CHANGE ADMIN_PASSWORD AFTER FIRST LOGIN!"
            echo "DJANGO_SETTINGS_MODULE=core.settings.prod"
            echo "ADMIN_USERNAME=admin"
            echo "ADMIN_PASSWORD=admin"
            echo "ADMIN_EMAIL=admin@example.com"
            echo "INITIAL_FIXTURES=True"
            echo ""
            echo "# Port configuration - default 2000 for Raspberry Pi"
            echo "HTTP_PORT=${HTTP_PORT_VAL}"
            echo "HTTPS_PORT=${HTTPS_PORT_VAL}"
            echo ""
            echo "# Sentry - disabled by default for Raspberry Pi"
            echo "SENTRY_DSN="
            echo "SENTRY_ENVIRONMENT=development"
            echo ""
            echo "# Redis configuration (password randomly generated)"
            echo "REDIS_HOST=redis"
            echo "REDIS_PASSWORD=${REDIS_PASSWORD}"
            echo ""
            echo "# Database configuration (password randomly generated)"
            echo "DATABASE_NAME=django"
            echo "DATABASE_USERNAME=docker"
            echo "DATABASE_PASSWORD=${DB_PASSWORD}"
            echo "DATABASE_HOST=db"
            echo "RABBITMQ_HOST=rabbitmq"
            echo ""
            echo "# Azure B2C - disabled by default"
            echo "AZURE_B2C_CLIENT_ID="
            echo "AZURE_B2C_CLIENT_SECRET="
            echo "AZURE_B2C_TENANT_NAME="
            echo "AZURE_B2C_POLICY_NAME="
            echo ""
            echo "# Email - disabled by default"
            echo "EMAIL_HOST="
            echo "EMAIL_PORT="
            echo "EMAIL_HOST_USER="
            echo "EMAIL_HOST_PASSWORD="
            echo "EMAIL_USE_TLS="
            echo "EMAIL_USE_SSL="
            echo "DEFAULT_FROM_EMAIL="
            echo ""
            echo "# Log rotation - reduced for Raspberry Pi storage constraints"
            echo "LOGROTATE_COPIES=7"
            echo "LOGROTATE_SIZE=50M"
            echo "LOGROTATE_INTERVAL=daily"
            echo ""
            echo "# App domain"
            echo "APP_DOMAIN=localhost"
            echo ""
            echo "# Plugins - minimal set for Raspberry Pi resource constraints"
            echo "PLUGINS=cloud_native_gis,reference_dataset"
        } > deployment/.env
        echo "âœ… deployment/.env file created"
        echo "   - SECRET_KEY: randomly generated"
        echo "   - DATABASE_PASSWORD: randomly generated"
        echo "   - REDIS_PASSWORD: randomly generated"
    else
        echo "âœ… deployment/.env already exists"
    fi
    
    # Create docker-compose override if not exists
    if [ ! -f deployment/docker-compose.override.yml ]; then
        echo "ðŸ”§ Creating docker-compose.override.yml..."
        cp deployment/docker-compose.override.template.yml deployment/docker-compose.override.yml
        echo "âœ… docker-compose.override.yml created"
    else
        echo "âœ… docker-compose.override.yml already exists"
    fi
    
    # Apply production webpack optimization (build once, not hot reload)
    echo "ðŸ”§ Applying production webpack optimization..."
    cp ../templates/docker-compose.override.production.yml deployment/docker-compose.override.production.yml
    echo "âœ… Production webpack override prepared (reduces CPU from 180% to near-zero)"

    # Sanitize compose files: remove obsolete 'version:' keys to avoid Compose V2 warnings
    sanitize_compose() {
        for f in deployment/docker-compose.yml deployment/docker-compose.override.yml deployment/docker-compose.override.arm64.yml deployment/docker-compose.override.production.yml; do
            if [ -f "$f" ]; then
                tmpfile=$(mktemp)
                awk '!/^[[:space:]]*version:/' "$f" > "$tmpfile" && mv "$tmpfile" "$f" || true
            fi
        done
    }
    sanitize_compose
    
    # Detect architecture and setup ARM64-specific builds if needed
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
        echo "ðŸ”§ Detected ARM64 architecture - setting up custom builds for compatibility..."
        
        # Copy custom Dockerfiles for ARM64-incompatible images
        echo "ðŸ“‹ Copying ARM64-compatible Dockerfiles..."
        mkdir -p deployment/dockerfiles
        if [[ ! -d deployment/dockerfiles/postgis ]]; then
            cp -r ../dockerfiles/postgis deployment/dockerfiles/
        fi
        if [[ ! -d deployment/dockerfiles/pg-backup ]]; then
            cp -r ../dockerfiles/pg-backup deployment/dockerfiles/
        fi
        echo "âœ… ARM64 Dockerfiles prepared"
        
        # Copy ARM64-specific docker-compose override (and repair old markdown-fenced versions)
        override_path="deployment/docker-compose.override.arm64.yml"
        template_path="../templates/docker-compose.override.arm64.yml"
        needs_refresh=0

        if [[ ! -f "$override_path" ]]; then
            needs_refresh=1
        elif [[ $(grep -c "\`\`\`" "$override_path" || true) -gt 0 ]]; then
            needs_refresh=1
        elif [[ $(grep -c '^services:' "$override_path" || true) -gt 1 ]]; then
            needs_refresh=1
        fi

        if [[ $needs_refresh -eq 1 ]]; then
            echo "ðŸ“‹ Creating ARM64-specific docker-compose override from template..."
            cp "$template_path" "$override_path"
            echo "âœ… Created deployment/docker-compose.override.arm64.yml"
        else
            echo "âœ… ARM64 docker-compose override already present"
        fi
        
        echo ""
        echo "âš ï¸  ARM64 Build Notice:"
        echo "   On first run, PostGIS and pg-backup will be built from source."
        echo "   This may take 15-30 minutes on Raspberry Pi."
        echo "   Subsequent runs will use cached images."
    fi
    
    # Pull required images for ARM64
    echo "ðŸ³ Pulling Docker images for ARM64..."
    ARCH=$(uname -m)
    PLATFORM="linux/amd64"
    [[ "$ARCH" == "arm64" || "$ARCH" == "aarch64" ]] && PLATFORM="linux/arm64"
    docker pull --platform=$PLATFORM ubuntu:22.04
    
    # Aggressive database cleanup to ensure fresh start
    echo ""
    echo "ðŸ§¹ Cleaning up any existing database data..."
    if [ -d "{{GEOSIGHT_DIR}}/deployment/volumes" ]; then
        echo "   Removing deployment/volumes directory..."
        sudo rm -rf {{GEOSIGHT_DIR}}/deployment/volumes || true
    fi
    
    # Remove any existing Docker volumes
    echo "   Removing Docker volumes..."
    docker volume ls -q | grep '^geosight_' | xargs -r docker volume rm 2>/dev/null || true
    
    echo "âœ… Database cleanup complete"
    
    echo ""
    echo "======================================"
    echo "  âœ… Installation complete!"
    echo "======================================"
    echo ""
    echo "Next steps:"
    echo "  1. Run 'just run' to start GeoSight"
    echo "  2. Access http://localhost:{{HTTP_PORT}}/"
    echo "  3. Login with admin / admin"
    echo ""
    echo "âš ï¸  SECURITY REMINDER:"
    echo "  Change the admin password immediately after first login!"
    echo ""

# Run GeoSight in development mode
run: _check-docker _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    # Function to detect and set platform
    set_docker_platform() {
        local arch=$(uname -m)
        if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then
            export DOCKER_DEFAULT_PLATFORM="linux/arm64"
            echo "ðŸ”§ Detected ARM64 architecture - setting DOCKER_DEFAULT_PLATFORM=linux/arm64"
        else
            export DOCKER_DEFAULT_PLATFORM="linux/amd64"
            echo "ðŸ”§ Detected AMD64 architecture - setting DOCKER_DEFAULT_PLATFORM=linux/amd64"
        fi
        echo ""
    }

    # Refresh ARM64 override file if the earlier install produced a malformed copy
    refresh_arm64_override_if_needed() {
        local arch=$(uname -m)
        if [[ "$arch" != "aarch64" && "$arch" != "arm64" ]]; then
            return 0
        fi

        local override_path="deployment/docker-compose.override.arm64.yml"
        local template_path="../templates/docker-compose.override.arm64.yml"
        local needs_refresh=0

        # Mark for refresh when missing, fenced, or duplicated top-level keys
        if [[ ! -f "$override_path" ]]; then
            needs_refresh=1
        elif [[ $(grep -c "\`\`\`" "$override_path" || true) -gt 0 ]]; then
            needs_refresh=1
        elif [[ $(grep -c '^services:' "$override_path" || true) -gt 1 ]]; then
            needs_refresh=1
        fi

        if [[ $needs_refresh -eq 1 ]]; then
            echo "ðŸ”§ Refreshing ARM64 override compose file from template (fixes fences/duplications)..."
            cp "$template_path" "$override_path"
        fi

        # Ensure ARM64-specific Dockerfiles exist (needed when install was run before this repo fix)
        mkdir -p deployment/dockerfiles
        if [[ ! -d deployment/dockerfiles/postgis ]]; then
            cp -r ../dockerfiles/postgis deployment/dockerfiles/
        fi
        if [[ ! -d deployment/dockerfiles/pg-backup ]]; then
            cp -r ../dockerfiles/pg-backup deployment/dockerfiles/
        fi
    }
    
    echo "======================================"
    echo "  Starting GeoSight"
    echo "======================================"
    echo ""
    
    cd {{GEOSIGHT_DIR}}
    
    # Set Docker timeouts for Raspberry Pi (slower I/O)
    export COMPOSE_HTTP_TIMEOUT={{COMPOSE_HTTP_TIMEOUT}}
    export DOCKER_CLIENT_TIMEOUT={{DOCKER_CLIENT_TIMEOUT}}

    sanitize_compose() {
        for f in deployment/docker-compose.yml deployment/docker-compose.override.yml deployment/docker-compose.override.arm64.yml deployment/docker-compose.override.production.yml; do
            if [ -f "$f" ]; then
                tmpfile=$(mktemp)
                awk '!/^[[:space:]]*version:/' "$f" > "$tmpfile" && mv "$tmpfile" "$f" || true
            fi
        done
    }
    
    # Detect platform for Docker
    set_docker_platform

    # Repair override/Dockerfiles that may have been created before the fix
    refresh_arm64_override_if_needed

    # Sanitize compose files again before build to ensure no 'version:' remains
    sanitize_compose
    
    # Create redis directory with correct permissions (required for redis container)
    REDIS_DIR="deployment/volumes/tmp_data/redis"
    if [ ! -d "$REDIS_DIR" ]; then
        echo "ðŸ“ Creating Redis directory with correct permissions..."
        if ! sudo mkdir -p "$REDIS_DIR"; then
            echo "âŒ Failed to create Redis directory: $REDIS_DIR"
            exit 1
        fi
    fi
    # Check ownership and fix if needed
    OWNER_UID=$(stat -c '%u' "$REDIS_DIR")
    OWNER_GID=$(stat -c '%g' "$REDIS_DIR")
    if [ "$OWNER_UID" != "999" ] || [ "$OWNER_GID" != "999" ]; then
        echo "ðŸ”‘ Fixing Redis directory ownership to 999:999..."
        if ! sudo chown -R 999:999 "$REDIS_DIR"; then
            echo "âŒ Failed to set ownership on Redis directory: $REDIS_DIR"
            exit 1
        fi
    fi
    
    # On ARM64, build custom images and use platform-specific override
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
        echo "ðŸ—ï¸  Building ARM64-compatible images..."
        echo "   (First build may take 15-30 minutes on Raspberry Pi)"
        echo ""
        
        # Build ARM64-specific images using buildx to ensure correct platform
        echo "ðŸ“¦ Building PostGIS image for ARM64 using buildx..."
        # Ensure buildx is available and a builder is selected
        if ! docker buildx version &>/dev/null; then
            echo "âš ï¸  docker buildx not available, falling back to 'docker compose build' (may pull wrong arch)"
            if ! docker compose -f deployment/docker-compose.yml \
                -f deployment/docker-compose.override.yml \
                -f deployment/docker-compose.override.arm64.yml \
                build db; then
                echo "âŒ Failed to build PostGIS image with docker compose"
                exit 1
            fi
        else
            # create/use a builder (idempotent)
            # Ensure binfmt emulators are registered so buildx can emulate architectures
            # Idempotent: running the installer multiple times is safe
            echo "ðŸ”§ Ensuring binfmt/qemu emulators are registered (may require privileged docker)..."
            docker run --privileged --rm tonistiigi/binfmt --install all || true

            # Ensure deployment/dockerfiles exists and contains the ARM64 Dockerfiles
            mkdir -p deployment/dockerfiles
            if [[ ! -d deployment/dockerfiles/postgis ]]; then
                cp -r ../dockerfiles/postgis deployment/dockerfiles/ || true
            fi
            if [[ ! -d deployment/dockerfiles/pg-backup ]]; then
                cp -r ../dockerfiles/pg-backup deployment/dockerfiles/ || true
            fi

            if ! docker buildx inspect geosight-builder &>/dev/null; then
                docker buildx create --name geosight-builder --use || true
            else
                docker buildx use geosight-builder || true
            fi

            # Build and load image for local docker (non-push) so compose can reference it
            if ! docker buildx build --platform=linux/arm64 -t geosight-postgis:13-arm64 deployment/dockerfiles/postgis --load; then
                echo "âŒ Failed to build PostGIS image with buildx"
                exit 1
            fi
            # Remove any existing amd64 tag for the upstream image so compose won't try to use it
            docker image rm kartoza/postgis:13.0 2>/dev/null || true
            # Tag the built ARM64 image with the upstream image name so compose uses local image
            docker tag geosight-postgis:13-arm64 kartoza/postgis:13.0 || true
        fi

        echo "ðŸ“¦ Building pg-backup image for ARM64 using buildx..."
        if ! docker buildx version &>/dev/null; then
            # Already warned above; try compose fallback
            if ! docker compose -f deployment/docker-compose.yml \
                -f deployment/docker-compose.override.yml \
                -f deployment/docker-compose.override.arm64.yml \
                build dbbackups; then
                echo "âŒ Failed to build pg-backup image with docker compose"
                exit 1
            fi
        else
            if ! docker buildx build --platform=linux/arm64 -t geosight-pg-backup:13-arm64 deployment/dockerfiles/pg-backup --load; then
                echo "âŒ Failed to build pg-backup image with buildx"
                exit 1
            fi
                # Tag pg-backup with upstream name to satisfy compose references
                docker image rm kartoza/pg-backup:13.0 2>/dev/null || true
                docker tag geosight-pg-backup:13-arm64 kartoza/pg-backup:13.0 || true
        fi
        
        echo "âœ… ARM64 images built successfully"
        echo ""
        
        # Run production mode with ARM64 override + production webpack optimization
        # Note: ARGS is passed to Makefile's docker compose command
        echo "ðŸ“‹ Using ARM64 platform override for compatibility..."
        echo "ðŸ“‹ Using production webpack build (reduces CPU from 180% to near-zero)"
        echo "ðŸš€ Starting Docker containers in PRODUCTION mode..."
        echo "   (This may take 10-30 minutes on first run on Raspberry Pi)"
        echo ""
        
        ARGS="-f deployment/docker-compose.yml -f deployment/docker-compose.override.yml -f deployment/docker-compose.override.arm64.yml -f deployment/docker-compose.override.production.yml" make up
    else
        # Run production mode without ARM64 override but with production webpack optimization
        echo "ðŸ“‹ Using production webpack build (reduces CPU from 180% to near-zero)"
        echo "ðŸš€ Starting Docker containers in PRODUCTION mode..."
        echo "   (This may take 10-30 minutes on first run on Raspberry Pi)"
        echo ""
        
        ARGS="-f deployment/docker-compose.yml -f deployment/docker-compose.override.yml -f deployment/docker-compose.override.production.yml" make up
    fi
    
    echo ""
    echo "â³ Waiting for database to be ready..."
    # Wait for database to be ready with proper health check
    # Timeout: 60 attempts Ã— 5 seconds = 5 minutes maximum wait
    MAX_ATTEMPTS=60
    ATTEMPT=0
    
    # Build docker compose command with appropriate files
    # Note: We use explicit -f flags here (not COMPOSE_FILE env var) because we're
    # calling docker-compose directly and want to be explicit about file order
    COMPOSE_CMD="docker compose -f deployment/docker-compose.yml -f deployment/docker-compose.override.yml"
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f deployment/docker-compose.override.arm64.yml"
    fi
    # Always apply production webpack optimization
    if [ -f deployment/docker-compose.override.production.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f deployment/docker-compose.override.production.yml"
    fi
    
    while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
        ATTEMPT=$((ATTEMPT + 1))
        if $COMPOSE_CMD exec -T db pg_isready -U docker -d django &>/dev/null; then
            echo "âœ… Database is ready (after $ATTEMPT attempts)!"
            break
        fi
        echo "   Attempt $ATTEMPT/$MAX_ATTEMPTS - waiting 5 seconds..."
        sleep 5
    done
    
    if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
        echo "âŒ Database failed to become ready after $MAX_ATTEMPTS attempts (5 minutes)"
        echo "   Check logs with: just logs"
        exit 1
    fi
    
    # Additional wait for other services
    echo "â³ Waiting for other services to initialize (30 seconds)..."
    sleep 30
    
    echo ""
    echo "======================================"
    echo "  âœ… GeoSight is running!"
    echo "======================================"
    echo ""
    echo "ðŸŒ Access GeoSight at: http://localhost:{{HTTP_PORT}}/"
    echo "ðŸ”‘ Login credentials: admin / admin"
    echo ""
    echo "âš ï¸  Initial Setup Required:"
    echo "   On first run, access the admin panel to complete database initialization."
    echo ""
    echo "Useful commands:"
    echo "  just stop     - Stop GeoSight"
    echo "  just status   - Show container status"
    echo "  just logs     - View logs"
    echo "  just tunnel   - Expose to internet via Cloudflare"
    echo ""

# Stop GeoSight
stop: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "ðŸ›‘ Stopping GeoSight..."
    cd {{GEOSIGHT_DIR}}
    
    # On ARM64, use additional platform-specific override
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
        export COMPOSE_FILE="deployment/docker-compose.yml:deployment/docker-compose.override.yml:deployment/docker-compose.override.arm64.yml"
    fi
    
    make down
    echo "âœ… GeoSight stopped"

# Restart GeoSight
restart: stop
    #!/usr/bin/env bash
    set -euo pipefail
    
    # Function to detect and set platform
    set_docker_platform() {
        local arch=$(uname -m)
        if [[ "$arch" == "aarch64" || "$arch" == "arm64" ]]; then
            export DOCKER_DEFAULT_PLATFORM="linux/arm64"
        else
            export DOCKER_DEFAULT_PLATFORM="linux/amd64"
        fi
    }
    
    echo "ðŸ”„ Restarting GeoSight..."
    cd {{GEOSIGHT_DIR}}
    
    export COMPOSE_HTTP_TIMEOUT={{COMPOSE_HTTP_TIMEOUT}}
    export DOCKER_CLIENT_TIMEOUT={{DOCKER_CLIENT_TIMEOUT}}
    
    # Detect platform for Docker
    set_docker_platform
    
    # Ensure redis directory has correct permissions
    sudo chown -R 999:999 deployment/volumes/tmp_data/redis 2>/dev/null || true
    
    # On ARM64, use additional platform-specific overrides including production
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
        echo "ðŸ“‹ Using ARM64 platform override + production webpack optimization..."
        ARGS="-f deployment/docker-compose.yml -f deployment/docker-compose.override.yml -f deployment/docker-compose.override.arm64.yml -f deployment/docker-compose.override.production.yml" make up
    else
        echo "ðŸ“‹ Using production webpack optimization..."
        ARGS="-f deployment/docker-compose.yml -f deployment/docker-compose.override.yml -f deployment/docker-compose.override.production.yml" make up
    fi
    
    echo ""
    echo "â³ Waiting for services to start..."
    sleep 30
    echo "âœ… GeoSight restarted"
    echo ""
    echo "ðŸŒ Access at: http://localhost:{{HTTP_PORT}}/"

# Load demo data into GeoSight
load-demo-data: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Loading Demo Data"
    echo "======================================"
    echo ""
    
    cd {{GEOSIGHT_DIR}}/deployment
    
    # Build docker compose command with appropriate files
    COMPOSE_CMD="docker compose -f docker-compose.yml -f docker-compose.override.yml"
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f docker-compose.override.arm64.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f docker-compose.override.arm64.yml"
    fi
    # Always apply production webpack optimization
    if [ -f docker-compose.override.production.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f docker-compose.override.production.yml"
    fi
    
    echo "ðŸ“Š Loading demo data..."
    echo "   This includes sample projects, indicators, and geographic data"
    echo ""
    
    if ! $COMPOSE_CMD exec -T django python manage.py load_demo_data; then
        echo "âŒ Failed to load demo data"
        exit 1
    fi
    
    echo ""
    echo "======================================"
    echo "  âœ… Demo Data Loaded!"
    echo "======================================"
    echo ""
    echo "ðŸŒ Access GeoSight at: http://localhost:{{HTTP_PORT}}/"
    echo "ðŸ“Š You should now see sample projects and data"
    echo ""

# Make demo project public (fix 403 permission errors)
make-demo-public: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Making Demo Project Public"
    echo "======================================"
    echo ""
    
    cd {{GEOSIGHT_DIR}}/deployment
    
    # Build docker compose command with appropriate files
    COMPOSE_CMD="docker compose -f docker-compose.yml -f docker-compose.override.yml"
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f docker-compose.override.arm64.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f docker-compose.override.arm64.yml"
    fi
    if [ -f docker-compose.override.production.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f docker-compose.override.production.yml"
    fi
    
    echo "ðŸ”“ Making demo project publicly accessible..."
    
    # Copy Python script to container
    $COMPOSE_CMD cp ../../scripts/make_demo_public.py django:/tmp/
    
    # Execute via Django shell
    $COMPOSE_CMD exec -T django sh -c 'cat /tmp/make_demo_public.py | python manage.py shell'
    
    echo ""
    echo "======================================"
    echo "  âœ… Demo Project Now Public!"
    echo "======================================"
    echo ""
    echo "ðŸŒ Try accessing the project again:"
    echo "   http://localhost:{{HTTP_PORT}}/en-us/project/demo-geosight-project"
    echo ""

# Uninstall GeoSight completely (remove all containers, volumes, images, and repository)
uninstall:
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Uninstalling GeoSight"
    echo "======================================"
    echo ""
    
    if [ -d "{{GEOSIGHT_DIR}}" ]; then
        cd {{GEOSIGHT_DIR}}
        
        # Stop and remove containers
        echo "ðŸ›‘ Stopping and removing containers..."
        
        # On ARM64, use additional platform-specific override
        ARCH=$(uname -m)
        if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
            export COMPOSE_FILE="deployment/docker-compose.yml:deployment/docker-compose.override.yml:deployment/docker-compose.override.arm64.yml"
        fi
        
        make down 2>/dev/null || true
        
        cd ..
        
        # Aggressively remove all GeoSight-related data
        echo ""
        echo "ðŸ—‘ï¸  Removing Docker volumes..."
        docker volume ls -q | grep '^geosight_' | xargs -r docker volume rm 2>/dev/null || true
        
        echo "ðŸ§¹ Removing local deployment/volumes directory..."
        sudo rm -rf {{GEOSIGHT_DIR}}/deployment/volumes 2>/dev/null || true
        
        echo "ðŸ—‘ï¸  Removing GeoSight-OS directory..."
        sudo rm -rf {{GEOSIGHT_DIR}}
        
        echo "ðŸ§¹ Cleaning up unused Docker resources..."
        docker system prune -f 2>/dev/null || true
        
        echo "âœ… Complete removal finished"
    else
        echo "âš ï¸  GeoSight-OS directory not found - nothing to uninstall"
    fi
    
    echo ""
    echo "âœ… Uninstall complete"

# Create Cloudflare Tunnel for internet access
tunnel: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Creating Cloudflare Tunnel"
    echo "======================================"
    echo ""
    
    # Check if cloudflared is installed
    if ! command -v cloudflared &> /dev/null; then
        echo "ðŸ“¦ Installing cloudflared..."
        
        # Detect architecture
        ARCH=$(uname -m)
        if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
            CLOUDFLARED_ARCH="arm64"
        else
            CLOUDFLARED_ARCH="amd64"
        fi
        
        # Download and install cloudflared
        CLOUDFLARED_URL="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-${CLOUDFLARED_ARCH}.deb"
        echo "   Downloading from: ${CLOUDFLARED_URL}"
        curl -L -o /tmp/cloudflared.deb "${CLOUDFLARED_URL}"
        sudo dpkg -i /tmp/cloudflared.deb
        rm /tmp/cloudflared.deb
        
        echo "âœ… cloudflared installed"
    else
        echo "âœ… cloudflared is already installed"
    fi
    
    echo ""
    echo "ðŸŒ Starting Cloudflare Tunnel..."
    echo ""
    echo "   This will create a temporary public URL for your GeoSight instance."
    echo "   The URL will be displayed below after the tunnel is established."
    echo ""
    echo "   âš ï¸  SECURITY WARNING:"
    echo "   - Anyone with this URL can access your GeoSight instance!"
    echo "   - This is NOT recommended for production use."
    echo "   - For production, use Cloudflare Zero Trust to add authentication:"
    echo "     https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/"
    echo ""
    echo "   Press Ctrl+C to stop the tunnel."
    echo ""
    
    cloudflared tunnel --url http://localhost:{{HTTP_PORT}}

# Run install and then run (full setup)
# Note: This may require manual intervention if docker group needs to be applied
doit:
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  Full GeoSight Setup (doit)"
    echo "======================================"
    echo ""
    
    # Run install first
    just install
    INSTALL_EXIT=$?
    
    # If install exited with code 0, docker group was already set, proceed to run
    if [ $INSTALL_EXIT -eq 0 ]; then
        echo ""
        echo "âœ… Installation complete, proceeding to run..."
        just run
    else
        # Install exited early, likely due to docker group addition
        echo ""
        echo "âš ï¸  Installation requires re-login to apply docker group."
        echo "   After logging back in, run: just run"
        exit 0
    fi

# Show container status
status: _check-docker
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "ðŸ“Š GeoSight Container Status:"
    echo ""
    if [ -d "{{GEOSIGHT_DIR}}" ]; then
        cd {{GEOSIGHT_DIR}}
        
        # Build docker compose command with appropriate files
        COMPOSE_CMD="docker compose -f deployment/docker-compose.yml -f deployment/docker-compose.override.yml"
        ARCH=$(uname -m)
        if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
            COMPOSE_CMD="$COMPOSE_CMD -f deployment/docker-compose.override.arm64.yml"
        fi
        
        $COMPOSE_CMD ps
    else
        echo "âš ï¸  GeoSight-OS directory not found. Run 'just install' first."
    fi

# View logs
logs: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    cd {{GEOSIGHT_DIR}}
    
    # Build docker compose command with appropriate files
    COMPOSE_CMD="docker compose -f deployment/docker-compose.yml -f deployment/docker-compose.override.yml"
    ARCH=$(uname -m)
    if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]] && [ -f deployment/docker-compose.override.arm64.yml ]; then
        COMPOSE_CMD="$COMPOSE_CMD -f deployment/docker-compose.override.arm64.yml"
    fi
    
    $COMPOSE_CMD logs -f

# Access Django shell
shell: _check-geosight
    #!/usr/bin/env bash
    set -euo pipefail
    
    cd {{GEOSIGHT_DIR}}
    make dev-shell

# Show system information relevant for GeoSight
info:
    #!/usr/bin/env bash
    set -euo pipefail
    
    echo "======================================"
    echo "  System Information"
    echo "======================================"
    echo ""
    echo "Architecture: $(uname -m)"
    echo "OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    echo "Kernel: $(uname -r)"
    echo ""
    echo "Memory:"
    free -h | head -2
    echo ""
    echo "Disk:"
    df -h / | tail -1
    echo ""
    if command -v docker &> /dev/null; then
        echo "Docker: $(docker --version)"
    else
        echo "Docker: Not installed"
    fi
    if [ -d "{{GEOSIGHT_DIR}}" ]; then
        echo "GeoSight-OS: Installed at ./{{GEOSIGHT_DIR}}"
    else
        echo "GeoSight-OS: Not installed"
    fi

